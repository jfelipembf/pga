const functions = require("firebase-functions/v1");
const { FieldValue } = require("firebase-admin/firestore");

// Local utilities
const { buildClientPayload, deriveFullName, buildAddress } = require("../../shared");

const { saveAuditLog } = require("../../shared/audit");
const { getActorSnapshot, getTargetSnapshot } = require("../../shared/snapshots");
const { getBranchCollectionRef } = require("../../shared/references");
const { requireAuthContext } = require("../../shared/context");
const { validate } = require("../../shared/validator");

// Schemas
const { ClientSchema } = require("../../shared");

/**
 * Logic: Create a new Client
 */
exports.createClientLogic = async (data, context) => {
    try {
        const { idTenant, idBranch } = requireAuthContext(data, context);

        if (!data.clientData) {
            throw new functions.https.HttpsError("invalid-argument", "clientData é obrigatório");
        }

        // Validate and sanitize
        const validatedData = validate(ClientSchema, data.clientData);

        // Get client reference
        const clientsRef = getBranchCollectionRef(idTenant, idBranch, "clients");
        const clientRef = clientsRef.doc();

        // Build payload (idGym will be generated asynchronously by trigger)
        const basePayload = buildClientPayload(validatedData);
        const payload = {
            ...basePayload,
            idGym: null, // Will be generated by onClientCreate trigger
            idGymPending: true, // Flag for trigger to process
            idTenant,
            idBranch,
            createdAt: FieldValue.serverTimestamp(),
            updatedAt: FieldValue.serverTimestamp(),
        };

        const actor = getActorSnapshot(context.auth);
        const target = getTargetSnapshot("client", { ...payload, id: clientRef.id }, clientRef.id);

        // Run DB set and Audit Log in parallel for performance
        await Promise.all([
            clientRef.set(payload),
            saveAuditLog({
                idTenant,
                idBranch,
                action: "CLIENT_CREATE",
                actor,
                target,
                description: `Criou o cliente ${payload.name} (ID pendente)`,
                metadata: { pendingIdGym: true }
            }).catch(err => console.error('[createClient] Audit log failed:', err))
        ]);

        return { id: clientRef.id, ...payload };
    } catch (error) {
        console.error("[createClientLogic] Error creating client:", error);
        if (error instanceof functions.https.HttpsError) throw error;
        throw new functions.https.HttpsError("internal", error.message || "Erro interno ao criar cliente");
    }
};

/**
 * Logic: Update a Client
 */
exports.updateClientLogic = async (data, context) => {
    try {
        const { idTenant, idBranch } = requireAuthContext(data, context);

        if (!data.idClient) {
            throw new functions.https.HttpsError("invalid-argument", "idClient é obrigatório");
        }

        if (!data.clientData) {
            throw new functions.https.HttpsError("invalid-argument", "clientData é obrigatório");
        }

        // Validate and sanitize
        const validatedData = validate(ClientSchema, data.clientData);

        // Get client reference
        const clientRef = getBranchCollectionRef(idTenant, idBranch, "clients", data.idClient);

        const payload = {
            ...validatedData,
            updatedAt: FieldValue.serverTimestamp(),
        };

        // Sync derived name if needed
        if (data.clientData.firstName !== undefined || data.clientData.lastName !== undefined || data.clientData.name !== undefined) {
            payload.name = deriveFullName(data.clientData);
        }

        // Sync address if needed
        if (data.clientData.address || data.clientData.street || data.clientData.city) {
            payload.address = buildAddress(data.clientData);
        }

        // Remove undefined values
        Object.keys(payload).forEach(key => payload[key] === undefined && delete payload[key]);

        // Audit log preparation
        const actor = getActorSnapshot(context.auth);
        const target = getTargetSnapshot("client", { ...payload, id: data.idClient }, data.idClient);

        // Run Update and Audit Log in parallel
        await Promise.all([
            clientRef.update(payload),
            saveAuditLog({
                idTenant,
                idBranch,
                action: "CLIENT_UPDATE",
                actor,
                target,
                description: `Atualizou o cliente ${payload.name || "..."}`,
                metadata: { updates: Object.keys(payload) }
            }).catch(err => console.error('[updateClient] Audit log failed:', err))
        ]);

        return { id: data.idClient, ...payload };

    } catch (error) {
        console.error("[updateClientLogic] Error updating client:", error);
        if (error instanceof functions.https.HttpsError) throw error;
        throw new functions.https.HttpsError("internal", error.message || "Erro interno ao atualizar cliente");
    }
};
